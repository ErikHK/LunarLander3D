precision mediump float;
uniform vec4 u_color;

uniform mat4 cammatrix;

uniform int drawterrain;
uniform int draw_landing_point;
uniform int draw_hudf;
uniform int draw_spaceship;
uniform int draw_skydomef;
uniform int draw_exhaustf;

uniform sampler2D tex0;

//mat3 lightCamMatrix;

uniform vec3 spaceship_pos;
uniform vec3 landing_point_pos;


varying float tf;

varying vec3 inPos;
varying vec2 texCoord;


varying mat4 cammat;
varying vec3 exNormal;
varying vec4 col;

vec4 cam_vector = vec4(.6,.6,.6,1);
vec3 n;
vec3 s;



//float rando(vec2 co){
//    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
//}

highp float rando(vec2 co)
{
    highp float a = 12.9898;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}


void main(){
  //lightCamMatrix = mat3(cammatrix);
  vec4 colors;

  n = normalize( exNormal );
  s = normalize(mat3(cammat)*normalize(vec3(.1,.3,.1)));

  float lambert = dot(n,s)-.001;

  float f = smoothstep(.05, .9, lambert);
  vec4  pixcolor1 = vec4(1, 1, 1, 1);
  vec4  pixcolor2 = vec4(.8, .8, .8, 1);

  if(draw_skydomef==1)
  {
    f = smoothstep(-.45, .45, inPos.y);
    pixcolor2 = vec4(.6, .9, 1., 1);
    pixcolor1 = vec4(.92, .98, 1, 1);
    colors = mix(pixcolor1, pixcolor2, f);
    //colors = pixcolor2 * vec4(1, 1, ((inPos.y+.5) + .4), 1);

  }

  if(draw_spaceship==1)
    colors = mix(pixcolor1, pixcolor2, f) * texture2D(tex0, texCoord);
  if(draw_exhaustf==1)
    colors = vec4(1, .4, 0, 1) * (inPos.y+.5)/1.0;
  if(drawterrain==1)
  {
    //colors = vec4(.3, .9, .3, 1)*lambert;

    if(lambert > 0.0)
    {
      f = smoothstep(.0, 1.0, lambert);
      //pixcolor1 = vec4(.2, .8, .2, 1);
      //pixcolor2 = vec4(.3, .9, .3, 1);
      //pixcolor2 = vec4(.55, .9, .36, 1);
      pixcolor2 = vec4(.87, 1.0, .55, 1);
      pixcolor1 = vec4(.25, .6, .06, 1);
      colors = mix(pixcolor1, pixcolor2, f);
      //colors = pixcolor2;
    }

    //colors += vec4(0, 4.0*rando(vec2(inPos.x/3.0, inPos.x/3.0)), 0, 0);

    float rand = .1*sin(inPos.x/3.2) + .08*sin(inPos.z/4.3) +
              .02*cos(inPos.y/5.0) + .007*cos(inPos.x*inPos.z)
              + .01*cos(sin(inPos.x )) + .003*sin(sin(tf*.4))
              + .03*clamp(tan(sin(inPos.x + inPos.y) + .02*cos(inPos.y*3.0) ), 0., 1.0);

    colors += vec4(0, .05*rando(vec2(int(inPos.x*20.0), int(inPos.z*20.0))) + rand*.1, 0, 0);

    if(inPos.y < 0.4 && inPos.y >= 0.2)
    {
      float ff = smoothstep(.2, .3, inPos.y);
      pixcolor1 = vec4(1.0, .95, .6, 1.0);
      //pixcolor2 = vec4(.45, .7, .26, 0);
      pixcolor2 = vec4(.87, 1.0, .55, 1);
       colors = mix(pixcolor1, pixcolor2, ff);
    }

    if(inPos.y < 0.2 && inPos.y >= 0.0)
    {
       colors = vec4(1.0, .95, .6, 1);
    }

    if(inPos.y < 0.0)
        {
          float rand = .01*sin(inPos.x/3.2 + tf*1.) + .08*sin(inPos.z/4.3 + tf*4.2) +
          .02*cos(inPos.y/5.0 + tf*1.0) + .007*cos(inPos.x*inPos.z + tf*3.0)
          + .01*cos(sin(inPos.x + 5.0*tf - tf*tf/100.0)) + .01*sin(sin(tf*.4))
          + .03*clamp(tan(sin(inPos.x + inPos.y) + cos(inPos.y*3.0) + tf*.5), 0., 1.0);

          colors = vec4(.4, .2 + .4*sin(inPos.x/3.0 + 2.0*tf) + rand, .9, 1);
        }

    //shadow on grass
    if(( spaceship_pos.x-inPos.x*1.)*(spaceship_pos.x-inPos.x*1.) +
    			(spaceship_pos.z-inPos.z*1.)*(spaceship_pos.z-inPos.z*1.) < 1.0 )
    				//colors -= vec4(.4,.4,.4,0);
    				colors = colors*.5;
  }

  if(draw_landing_point==1)
  {
    f = smoothstep(.2, .9, lambert);
    pixcolor1 = vec4(.8, .4, .0, 1);
    pixcolor2 = vec4(1.0, .6, .0, 1);
    //colors = mix(pixcolor1, pixcolor2, f)*texture2D(tex, texCoord);
    //colors = vec4(1.0, .6, .0, 1)*lambert;

    colors = lambert*texture2D(tex0, texCoord) + vec4(1.0, .5, .1, 1.0) * sin(3.*tf)*sin(3.*tf)/1.4;

    //shadow on landing point
    float distdiff = spaceship_pos.y-inPos.y;
    if(((spaceship_pos.x-inPos.x*4. - landing_point_pos.x)*(spaceship_pos.x - inPos.x*4. - landing_point_pos.x) +
        			(spaceship_pos.z - inPos.z*4. - landing_point_pos.z)*(spaceship_pos.z - inPos.z*4. - landing_point_pos.z) < .7))
        				//colors -= vec4(.4,.4,.4,0);
        				colors = colors*.5;
  }

  if(draw_hudf==1)
  {
    //colors = vec4(.9, .1, .1, 1.0);
    colors = texture2D(tex0, texCoord*1.0);
  }

  gl_FragColor = colors;

}

