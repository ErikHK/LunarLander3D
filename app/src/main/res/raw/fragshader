precision mediump float;
uniform vec4 u_color;

uniform mat4 cammatrix;
uniform int drawterrain;
uniform int draw_landing_point;
uniform int draw_hudf;
uniform sampler2D tex;

//mat3 lightCamMatrix;

uniform vec3 spaceship_pos;
uniform vec3 landing_point_pos;

varying float tf;

varying vec3 inPos;
varying vec2 texCoord;


varying mat4 cammat;
varying vec3 exNormal;
varying vec4 col;

vec4 cam_vector = vec4(.6,.6,.6,1);
vec3 n;
vec3 s;

void main(){
  //lightCamMatrix = mat3(cammatrix);
  vec4 colors;

  n = normalize( exNormal );
  s = normalize(mat3(cammat)*normalize(vec3(1,1,1)));

  float lambert = pow(dot(n,s), 1.0);

  float f = smoothstep(.05, .9, lambert);
  //vec4  pixcolor1 = vec4(.6, .05, .05, 1);
  //vec4  pixcolor2 = vec4(.8, .3, .3, 1);
  vec4  pixcolor1 = vec4(1, 1, 1, 1);
  vec4  pixcolor2 = vec4(.8, .8, .8, 1);
  colors = mix(pixcolor1, pixcolor2, f) * texture2D(tex, texCoord);
  //colors = texture2D(tex, texCoord) * lambert;
  //colors = mix(pixcolor1, pixcolor2, f);

  if(drawterrain==1)
  {
    //colors = vec4(.3, .9, .3, 1)*lambert;

    f = smoothstep(.2, .9, lambert);
    pixcolor1 = vec4(.2, .8, .2, 1);
    pixcolor2 = vec4(.3, .9, .3, 1);
    colors = mix(pixcolor1, pixcolor2, f);


    if(inPos.y < 0.0)
        {

          float rand = .01*sin(inPos.x/3.2 + tf*1.) + .08*sin(inPos.z/4.3 + tf*4.2) +
          .02*cos(inPos.y/5.0 + tf*1.0) + .007*cos(inPos.x*inPos.z + tf*3.0)
          + .01*cos(sin(inPos.x + 5.0*tf - tf*tf/100.0)) + .01*sin(sin(tf*.4))
          + .03*clamp(tan(sin(inPos.x + inPos.y) + cos(inPos.y*3.0) + tf*.5), 0., 1.0);


          colors = vec4(.4, .2 + .2*sin(inPos.x/2. + 2.0*tf) + rand, .9, 1);

          //gl_Normal.y = 1;
        }

    if(((spaceship_pos.x-inPos.x*1.)*(spaceship_pos.x-inPos.x*1.) +
    			(spaceship_pos.z-inPos.z*1.)*(spaceship_pos.z-inPos.z*1.) < 1.0))
    				colors -= vec4(.4,.4,.4,0);

  }

  if(draw_landing_point==1)
  {

    f = smoothstep(.2, .9, lambert);
    pixcolor1 = vec4(.8, .4, .0, 1);
    pixcolor2 = vec4(1.0, .6, .0, 1);
    colors = mix(pixcolor1, pixcolor2, f);
    //colors = vec4(1.0, .6, .0, 1)*lambert;

    if(((spaceship_pos.x-inPos.x*2. - landing_point_pos.x)*(spaceship_pos.x - inPos.x*2. - landing_point_pos.x) +
        			(spaceship_pos.z - inPos.z*2. - landing_point_pos.z)*(spaceship_pos.z - inPos.z*2. - landing_point_pos.z) < .5))
        				colors -= vec4(.4,.4,.4,0);
  }

  if(draw_hudf==1)
  {
    colors = vec4(.9, .1, .1, 1.0);
  }

  gl_FragColor = colors;

}